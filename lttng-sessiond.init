#!/bin/sh
### BEGIN INIT INFO
# Provides:          lttng-sessiond
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: The LTTng session daemon
# Description:       Main daemon for trace session registry for UST and LTTng
### END INIT INFO

# Inspired by Debian init script done by Jon Bernard <jbernard@debian.org>

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC=lttng-sessiond            # Introduce a short description here
NAME=lttng-sessiond            # Introduce the short server's name here
DAEMON=/usr/local/bin/lttng-sessiond # Introduce the server's location here
DAEMON_ARGS="-d"               # Arguments to run the daemon with
SCRIPTNAME=/etc/init.d/$NAME

# Exit if the package is not installed
[ -x $DAEMON ] || exit 0

if [ -e /etc/sysconfig/lttng-sessiond ]; then
  . /etc/sysconfig/lttng-sessiond
fi

# source function library
. /etc/rc.d/init.d/functions


# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions

#
# Function that starts the daemon/service
#
do_start()
{

    start_daemon $DAEMON $DAEMON_ARGS
    RETVAL=$?
    echo
    return $RETVAL

    # Return
    #   0 if daemon has been started
    #   1 if daemon was already running
    #   2 if daemon could not be started
    #start-stop-daemon --start --quiet --exec $DAEMON --test > /dev/null \
    #    || return 1
    #start-stop-daemon --start --quiet --exec $DAEMON -- $DAEMON_ARGS \
    #    || return 2
    # Add code here, if necessary, that waits for the process to be ready
    # to handle requests from services started subsequently which depend
    # on this one.  As a last resort, sleep for some time.
}

#
# Function that stops the daemon/service
#
do_stop()
{
    killproc $NAME -TERM
    RETVAL=$?
    echo
    return $RETVAL
}

#
# Function that sends a SIGHUP to the daemon/service
#
do_reload() {
    #
    # If the daemon can reload its configuration without
    # restarting (for example, when it is sent a SIGHUP),
    # then implement that here.
    #
    killproc $NAME -HUP
    return 0
}

case "$1" in

    start)
        MSG="Starting $DESC "
        do_start
        case "$?" in
            0|1) log_success_msg $MSG ;;
            2)   log_failure $MSG ;;
        esac
        ;;

    stop)
        MSG="Stopping $DESC" 
        do_stop
        case "$?" in
            0|1) log_success_msg $MSG ;;
            *)   log_failure_msg $MSG ;;
        esac
        ;;

    status)
        status "$DAEMON"  && exit 0 || exit $?
        ;;

    restart|force-reload)
        echo "Restarting $DESC" "$NAME"
        do_stop
        case "$?" in
            0|1)
                do_start
                case "$?" in
                    0) log_end_msg 0 ;;
                    1) log_end_msg 1 ;; # Old process is still running
                    *) log_end_msg 1 ;; # Failed to start
                esac
                ;;
            *)
                # Failed to stop
                log_end_msg 1
                ;;
        esac
        ;;

    *)
        echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload}" >&2
        exit 3
        ;;
esac
